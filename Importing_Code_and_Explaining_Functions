#@markdown Run this cell for imports and functions
#@markdown 
!pip install qutip

import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import qutip

def spinup(n):
    return [[np.random.randint(2) - 1/2, np.random.randint(2) - 1/2, 1/2] 
            for i in range(n)]

def spindown(n):
    return [[np.random.randint(2) - 1/2, np.random.randint(2) - 1/2, -1/2] 
            for i in range(n)]

def all_S(spin_ensemble):
    return [sum(j[i] for j in spin_ensemble) for i in range(3)]

def single_spin_rotation_along_z(spin, amount):
    rotation_matrix = [[np.cos(amount), np.sin(amount), 0], 
                       [- np.sin(amount), np.cos(amount), 0], [0, 0, 1]]
    spin = np.dot(np.array(rotation_matrix), spin)
    return spin
    
def single_spin_rotation_along_y(spin, amount):
    rotation_matrix = [[np.cos(amount), 0, - np.sin(amount)], [0, 1, 0], 
                       [np.sin(amount), 0, np.cos(amount)]]
    spin = np.dot(np.array(rotation_matrix), spin)
    return spin

def single_spin_rotation_along_x(spin, amount):
    rotation_matrix = [[1, 0, 0], [0, np.cos(amount), -np.sin(amount)], 
                       [0, np.sin(amount), np.cos(amount)]]
    spin = np.dot(np.array(rotation_matrix), spin)
    return spin

def show_on_bloch(spin_realization, N):
    b = qutip.Bloch()
    b.sphere_alpha = 0.0
    b.frame_alpha = 0.05
    b.add_points(np.array([spin/np.sqrt(N/2*(N/2+1)) 
                            for spin in spin_realization]).T)
    b.point_color=['C0']
    b.point_marker = '.'
    b.zlabel = ['$z$', '']
    b.render()
    
Explain the functions:

def spinup(n): take atom number N as input, return an array of N random 3-d vectors, each of them is (±0.5,±0.5,0.5). Input: N, Output: [s1,s2,⋯,sN]

def spindown(n): take atom number N as input, return an array of N random 3-d vectors, each of them is (±0.5,±0.5,−0.5). Input: N, Output: [s1,s2,⋯,sN]

def all_S(spin_ensemble): take an array of N random 3-d vectors as input, return a 3-d vector, as a sum of all vectors in the array. Input: [s1,s2,⋯,sN], output: Sα=x,y,z=∑Nisαi

def single_spin_rotation_along_z(spin, amount): take a 3-d vector and "amount" as input, return a 3-d vector with a rotation of it along z-direction by "amount". Input: s=[sx,sy,sz], Output: s′=[s′x,s′y,s′z]

def single_spin_rotation_along_y(spin, amount): take a 3-d vector and "amount" as input, return a 3-d vector with a rotation of it along y-direction by "amount". Input: s=[sx,sy,sz], Output: s′=[s′x,s′y,s′z]

def single_spin_rotation_along_x(spin, amount): take a 3-d vector and "amount" as input, return a 3-d vector with a rotation of it along x-direction by "amount". Input: s=[sx,sy,sz], Output: s′=[s′x,s′y,s′z]

def show_on_bloch(spin_realization, N): take an array of M random 3-d vectors, and atom number N as input, plot the array on a Bloch sphere. Note that the spin_realization contains M, the number of random realizations, of the 3-d vectors, and each vector should be calculated by all_S. Input: [S1,S2,⋯,SM] and  N
